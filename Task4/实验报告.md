# 循环赛算法实验报告

###### 班级：2018211303	姓名：马嘉骥	学号：2018211149

## 算法目的

* 设有n个运动员要进行网球循环赛。设计一个满足下列条件的比赛日程表：
	* 每个选手必须与其他n-1个选手各赛一次。
	* 每个选手一天只能赛一次。
	* 当n是偶数时，循环赛进行n-1天。
	* 当n是奇数时，循环赛进行n天。

## 算法分析

* 对于选手数量为偶数的情况，按分治策略，将所有的选手分为两半，n个选手的比赛日程表就可以通过为n/2个选手设计的比赛日程表来决定。递归地对选手进行分割，直到只剩下2个选手时，比赛日程表的制定就变得很简单。这时只要让这2个选手进行比赛就可以了。
* 当选手数量不是2的n次幂时，在进行二分的时候会遇到选手数量为奇数的情况。对于该情况，创建一个虚拟选手，将人数向上补齐为偶数再二分进行比赛日程安排。在完成安排之后，将该选手删除，并且将其余所有选手与该虚拟选手比赛的当天比赛对手改为0，表示该选手当天没有比赛。
* 构造方法：
  * 安排方法：
  	* 当选手数量为2时，用一天时间让两个选手互相比赛。
  	* 当选手大于2时，对（选手数量除以2再向上取整）个选手进行安排，再将安排结果混合到（选手数量）个选手的安排表中。
  	
  	```c++
  	void Schedule(int playerNum, std::vector<std::vector<int>> &table) {
  	    if (playerNum == 2) {
  	        table[1][1] = 2;
  	        table[2][1] = 1;
  	    } else {
  	        //if playerNum>2, solve problem n = ceil(playerNum/2.0), if n still>2, continue splitting until n == 2
  	        Schedule((int) ceil(playerNum / 2.0), table);
  	        Merge(playerNum, table);
  	    }
  	}
  	```
  	
  * 混合方法：对于将n/2个选手的安排表，混合到n个选手的安排表，则：
    * 利用前`halfPlayerNum`个选手的赛程，构造出后`halfPlayerNum`个选手的安排。安排方式：仿照前n/2个选手之间相互比赛的关系，让`i + halfPlayerNum`号选手与比`table[i][j]`大`halfPlayerNum`的选手比赛，即：`table[i + halfPlayerNum][j] = table[i][j] + halfPlayerNum; (1 ≤ i ≤ halfPlayerNum, 1 ≤ j ≤ daysMerged, i代表队员， j代表当前比赛的天数)`。因为前`halfPlayerNum`个队员没有和后`halfPlayerNum`个队员比赛过，前`halfPlayerNum`个队员在前`daysMerged`天各自的比赛对象`table[i][j]` 是各不相同的，所以后`halfPlayerNum`个队员的安排也是各不相同，且覆盖了全部的后`halfPlayerNum`个队员的。

    ```c++
    int halfPlayerNum = (int) ceil(playerNum / 2.0);
    int daysTotal = playerNum % 2 == 0 ? playerNum - 1 : playerNum;
    int daysMerged = halfPlayerNum % 2 == 0 ? halfPlayerNum - 1 : halfPlayerNum;
    // construct schedule table for the last half player from the first day to daysMerged st day
    for (int i = 1; i <= halfPlayerNum; i++) {
        for (int j = 1; j <= daysMerged; j++) {
            if (table[i][j] != 0) {
                // if player i has rival on day j, let player (i + hPN) play with (i's rival number + hPN)th player
                table[i + halfPlayerNum][j] = table[i][j] + halfPlayerNum;
            } else {
                // if player i has no rival on day j, let i and (i + hPN) be rivals
                table[i + halfPlayerNum][j] = i;
                table[i][j] = i + halfPlayerNum;
            }
        }
    }
    ```

    * 利用n个选手在前`daysMerged`天的日程安排，构造出这些队员在后`daysTotal - daysMerged`天的日程安排。为了保证选手的比赛不重复并且每两个人都互相比赛过，让前`halfPlayerNum`个选手与后`halfPlayerNum`个选手两两比赛。`rvalue = (count + i-1) % halfPlayerNum + halfPlayerNum + 1;`保证`i`队员与后面的队员（`rvalue`必然大于`halfPlayerNum`）比赛，这样就与前面`daysMerged`天的比赛不重复。`count`初始值为0，`j`每加1，`count++`。`table[i][j] = rvalue; table[rvalue][j] = i; `相当于每一column的比赛对手都是1到n的循环，相邻的column之间相位相差1。
    * n为奇数时，需要把`halfPlayerNum+1`列删除，并且将与`halfPlayerNum+1`比赛的位置置0。由于置0，横向构造的时候如果`table[i][j]`为0，则直接让他与`i+halfPlayerNum`号选手比赛。同时添加一个标记`oddFlag=1`，表示出现了奇数的选手，在后面构造下半部分的时候`rValue = (count + (i - 1) + oddFlag) % halfPlayerNum + halfPlayerNum + 1;`，可以避免第一个纵向构造的选手和之前置0处填上的选手重复。由于采用了增量构造，因此只要第一个选手不出现重复，那么之后的选手都不会出现重复。

    ```c++
    int oddFlag = 0;
    if (table[1][daysMerged] == halfPlayerNum + 1) {
        oddFlag = 1;
    }
    for (int i = 1; i <= halfPlayerNum; i++) {
        for (int j = daysMerged + 1, count = 0; j <= daysTotal; j++, count++) {
            //construct opponent for player i on day j
            int rValue = (count + (i - 1) + oddFlag) % halfPlayerNum + halfPlayerNum + 1;
            table[i][j] = rValue;
            table[rValue][j] = i;
        }
    }
    //remove virtual player if exists
    if (playerNum % 2 == 1) {
        for (int i = 1; i <= 2 * halfPlayerNum; i++) {
            for (int j = 1; j <= daysTotal; j++) {
                if (table[i][j] == playerNum + 1) {
                    table[i][j] = 0;
                }
            }
        }
    }
    ```

## 算法源码

* RoundRobin.cpp

```c++
#include "RoundRobin.h"

void Merge(int playerNum, std::vector<std::vector<int>> &table) {
    int halfPlayerNum = (int) ceil(playerNum / 2.0);
    int daysTotal = playerNum % 2 == 0 ? playerNum - 1 : playerNum;
    int daysMerged = halfPlayerNum % 2 == 0 ? halfPlayerNum - 1 : halfPlayerNum;
    // construct schedule table for the last half player from the first day to daysMerged st day
    for (int i = 1; i <= halfPlayerNum; i++) {
        for (int j = 1; j <= daysMerged; j++) {
            if (table[i][j] != 0) {
                // if player i has rival on day j, let player (i + hPN) play with (i's rival number + hPN)th player
                table[i + halfPlayerNum][j] = table[i][j] + halfPlayerNum;
            } else {
                // if player i has no rival on day j, let i and (i + hPN) be rivals
                table[i + halfPlayerNum][j] = i;
                table[i][j] = i + halfPlayerNum;
            }
        }
    }

    int oddFlag = 0;
    if (table[1][daysMerged] == halfPlayerNum + 1) {
        oddFlag = 1;
    }
    for (int i = 1; i <= halfPlayerNum; i++) {
        for (int j = daysMerged + 1, count = 0; j <= daysTotal; j++, count++) {
            //construct opponent for player i on day j
            int rValue = (count + (i - 1) + oddFlag) % halfPlayerNum + halfPlayerNum + 1;
            table[i][j] = rValue;
            table[rValue][j] = i;
        }
    }
    //remove virtual player if exists
    if (playerNum % 2 == 1) {
        for (int i = 1; i <= 2 * halfPlayerNum; i++) {
            for (int j = 1; j <= daysTotal; j++) {
                if (table[i][j] == playerNum + 1) {
                    table[i][j] = 0;
                }
            }
        }
    }
}

void Schedule(int playerNum, std::vector<std::vector<int>> &table) {
    if (playerNum == 2) {
        table[1][1] = 2;
        table[2][1] = 1;
    } else {
        //if playerNum>2, solve problem n = ceil(playerNum/2.0), if n still>2, continue splitting until n == 2
        Schedule((int) ceil(playerNum / 2.0), table);
        Merge(playerNum, table);
    }
}
```

* RoundRobin.h

```c++
#ifndef FINALTEST_ROUNDROBIN_H
#define FINALTEST_ROUNDROBIN_H

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <vector>

void Schedule(int playerNum, std::vector<std::vector<int>> &table);

#endif //FINALTEST_ROUNDROBIN_H
```

## 测试代码

## 运行结果

## 小结